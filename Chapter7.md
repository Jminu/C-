# 프렌드와 연산자 중복

### 프렌드 개념

​	C++에서는 클래스 외부에 작성된 함수를 클래스내에 friend키워드로 선언하여, 클래스의 멤버함수와 동일한 접근 자격을 부여할 수 있다. **멤버함수가 아니기 때문에 상속x**, friend키워드로 선언된 외부 함수를 **friend함수**라고 부르며, 클래스의 멤버처럼 사용할 수 있다. 프렌드 함수만 존재하며, **프렌드 변수는 없다.**

### 프렌드 함수의 필요성

​	클래스 멤버 함수로는 적합하지 않지만, 클래스의 private, protected멤버를 접근해야 하는 특별한 경우 외부에 함수로 작성하고 friend로 선언한다. 

+ 클래스 외부에 작성된 함수 프렌드로 선언
+ 다른 클래스의 멤버 함수를 프렌드로 선언
+ 다른 클래스의 모든 멤버 함수를 프렌드로 선언

### 프렌드 함수 선언

​	클래스 외부에 구현된 함수를 **friend 키워드**로 클래스 내의 아무 곳에나 선언한다. 

### 전방 참조 문제를 해결하기 위한 전방 선언

### 프렌드 멤버 선언

​	다른 클래스의 멤버 함수를 클래스의 프렌드 함수로 선언할 수 있다.

```cpp
class Rect {
  ...
 	friend bool RectManager::equals(Rect r, Rect s);
}
```

​	이렇게 함으로써, RectManager클래스의 멤버 함수인 equals는 Rect클래스의 모든 멤버를 접근할 수 있다. 

### 프렌드 클래스 선언

​	다른 클래스의 모든 멤버 함수를 클래스의 프렌드 함수로 한 번에 선언할 수 있다. 하지만, 이렇게 한다면 캡슐화의 원칙에 위배되기 때문에 추천하지 않음.

# 연산자 중복

​	동일한 연산 혹은 기호를 피연산자에 따라 다르게 해석하는 것을 연산자 중복이라 한다. **다형성**이라 볼 수 있다. operator overloading

### 연산자 중복의 특징

+ C++언어에 본래 있는 연산자만 중복 가능하다
+ 피연산자의 타입이 다른 연산을 새로 정의
+ 함수를 통해 이루어진다
+ 반드시 클래스와 관계를 가진다
+ 피연산자의 개수를 바꿀 수 없다
+ 연산의 우선순위를 바꿀 수 없다
+ 모든 연산자가 중복 가능한 것은 아니다

### 연산자 함수 선언과 연산자 함수 개요

​	연산자 함수는 **연산자 함수**를 통해 구현된다.

+ 클래스의 **멤버 함수**로 구현
+ **외부 함수**로 구현하고 클래스의 **프렌드 함수**로 선언

리턴타입 operator 연산자(매개변수리스트) 형식으로 선언한다.

## 이항 연산자 중복

### + 연산자 중복

예를 들어서 

```cpp
class Power {
  int kick;
  int punch;
  public:
  	Power(int kick = 0, int punch = 0) {
      this->kick = kick;
      this->punch = punch;
    }
};
```

이런 클래스가 있다고 가정해보자

만약에,

```cpp
Power a;
Power b;
Power c;

c = a + b;
```

이렇게 한다면 + 연산은 수만 더할 수 있다. 그래서 +연산자를 정의를 해야한다.(클래스끼리 더할 수 있도록)



```cpp
class Power{
  Power operator + (Power op2);
}

a. + (b)이렇게 되는데,
op2는 b가 된다.
```

만약 a + b는 컴파일러는 **a. + (b)**이렇게 해석한다.



연산자 함수 구현은 이렇게 한다.

```cpp
Power Power::operator + (Power op2) {
  Power tmp;
  tmp.kick = this->kick + op2.kick;
  tmp.punch = this->punch + op2.punch;
  
  return tmp; //객체를 반환
}
```

---

### += 연산자 중복

​	+= 연산자 중복을 이용할 때, 복사본에 값을 더하는 상태가 된다. 이런 문제를 해결하기 위해서 리턴 타입을 참조형으로 선언한다. 예를 들어서, a += b의 연산이 객체 a의 참조를 리턴하면 된다.

```cpp
Power &Power::operator += (Power op2) {
    kick = kick + op2.kick;
    punch = punch + op2.punch;
    
    return *this; //자신 객체의 참조를 리턴한다.
}
```

## 단항 연산자 중복

​	피연산자가 하나인 단항 연산자의 중복 구현, 단항 연산자이기 때문에 매개변수가 없다. 컴파일러는 ++a의 식을 이렇게 변형한다. **a . ++ ();** 또한 리턴타입도 참조리턴을 해야한다.

### 전위 ++ 연산자 중복

```cpp
Power &Power::operator ++ () {
  kick++;
  punch++;
  return *this; //자신(*this)에 대한 참조를 리턴한다.
}
```

### 후위 ++연산자 중복

​	전위 연산자와 후위 연산자를 구분하기 위해서 후위 연산자는 **매개 변수를 가지도록 선언**한다.

```cpp
Power operator ++ (); //전위
Power operator ++ (int x); //후위
```

여기서 매개변수 x는 의미없는 값이니 무시하자. 그리고 **참조를 리턴해선 안된다.** 연산자 함수는 이렇게 구현한다.

```cpp
Power Power::operator ++ (int x) {
  Power tmp = *this; //증가 이전 객체 상태를 저장한다.
  kick++;
  punch++;
  
  return tmp; //증가 이전의 객체를 리턴한다.
}
```

### friend를 이용한 연산자 중복

​	만약 b = 2 + a를 계산한다고 가정해보자. 컴파일러는 이것을 **b = 2 . + (a)**로 변형하여 함수를 호출하려고 한다. 하지만 2는 객체가 아니므로 잘못된 방식이다. 첫번째 피연산자가 객체가 아니라면 컴파일러는 이렇게 변형 한다. **b = + ( 2 , a )** 따라서 **외부 함수**로 따로 구현해야 한다.

함수를 구현해보면 이렇다.

```cpp
Power operator + (int op1, Power op2) {
  Power tmp;
  tmp.kick = op1 + op2.kick;
  tmp.punch= op1 + op2.punch;
  
  return tmp;
}
```

하지만 이렇게 한다면 private변수인 kick과 punch를 접근할 수 없다. 접근하려면 public으로 선언해야하는데 그러면 캡슐화의 원칙이 무너지게 된다. 그러므로 Power클래스에 프렌드 멤버로 초대하면 해결된다!


# 객체 포인터와 객체 배열, 객체의 동적 생성

## 객체 포인터

​	C++에서 객체를 다루기 위해 **객체에 대한 포인터** 변수를 선언하고, 이 포인터를 이용한다.

```cpp
d = p->getArea();
d = (*p).getArea(); //*p = 포인터 p가 가르키는 것
```

​	이 두 줄의 코드는 동일하다. 

## 객체 배열

​	원소가 **객체**라는 점을 빼고, 일반적인 배열과 동일하다.

```cpp
Circle circleArray[3]; //Circle의 객체의 배열을 3개 생성.
```

​	이런식으로 선언한다.

### 객체 배열 선언문은 기본 생성자를 호출한다.

​	객체 배열 선언으로 생성된 객체들은 **기본 생성자**를 호출한다. 만약, 기본 생성자가 아닌 다른 생성자가 있다면 객체 배열을 생성할때 기본 생성자를 찾지 못하므로(기본 생성자 자동삽입은 생성자가 아예 없을 때) 컴파일 오류를 발생시킨다. 따라서 객체 배열을 선언할 때, **기본 생성자가 있는지** 확인하자!!

### 배열 소멸과 소멸자

​	함수 종료되면? 함수내에 선언된 배열도 소멸된다. **각 원소 객체마다 소멸자가 호출된다.** 생성순의 반대로 소멸자 실행!

### 객체 포인터를 사용하여 객체 배열을 다루는 다양한 사례

​	나중에 적기.

### 객체 배열 초기화

​	객체 배열 생성할 때 **생성자**를 사용하여 원소 객체를 초기화 할 수 있다.

```cpp
Circle circleArray[3] = {Circle(10), Circle(20), Circle()};
```

### 다차원 객체 배열

​	이것도 그냥 하던대로 하면됨

## 동적 메모리 할당 및 반환

​	필요한 만큼 메모리를 할당받고 필요 없을 때 반환하기 위해서. **new**연산자와 **delete**연산자를 이용한다. **new**연산자를 **heap**에서 메모리를 할당받고, **delete**는 메모리를 힙으로 반환한다.

​	heap메모리가 부족하면 new는 **NULL**을 리턴한다. 그래서 항상 new의 리턴 값이 NULL인지 검사하는게 좋다.

### 동적 할당 메모리 초기화

​	예시)

```cpp
int *pint = new int(20); //20으로 초기화된 int 공간 할당
int *pchar = new char('a'); //'a'로 초기화된 char 공간 할당
```

### delete사용 시 주의

​	반환할 때, 적절하지 못한 포인터를 사용하면, 실행 오류가 발생한다. 그리고 동일한 메모리 2번 반환하면 오류임!

## 배열의 동적 할당 및 반환

​	new 연산자는 **'배열의 크기'**만한 배열을 할당받아 주소를 리턴하며, delete는 **'포인터 변수'**가 가리키는 배열 메모리를 반환한다.

### 배열을 초기화 할 때 주의 사항

```cpp
int *pArray = new int[10](20); // 배열의 초기화 불가능
int *pArray = new int(20)[10]; // 이것도 안된다
```

​	**이렇게 직접 초깃값을 지정할 수 없다.**

​	근데 이렇게 하는건 가능하다.

```cpp
int *pArray = new int[] {1, 2, 3, 4}; // 1, 2, 3, 4로 초기화된 정수 배열 생성
```

### 배열을 delete 할 때 주의 사항

```cpp
int *p = new int[10];
delete []p; //배열을 가리키는 포인터 p를 반환
```

## 객체와 객체 배열의 동적 생성 및 반환

### 만약 매개 변수 없는 생성자를 호출 때

```cpp
Circle waffle; // 맞음.

Circle waffle(); // 틀림. why? Circle 객체를 리턴하는 함수로 인식한다.
```



하지만,

```cpp
Circle *p = new Circle; //맞음

Circle *p = new Circle(); //맞음
```

이 두 문장은 문제가 없다.

### 객체 배열의 동적 생성과 생성자

​	객체 배열을 동적 할당받을 때, 객체는 **기본 생성자**를 호출한다. 따라서 객체의 배열을 동적할당 할 때, 매개변수가 있는 생성자를 직접 호출할 수 없다. 하지만, 배열을 각 원소 객체로 초기화 할 수 있다.

```cpp
Circle *p = new Circle[3] {Circle(10), Circle(20), Circle(30)}; //이렇게 하는건 가능하다.
```

### 객체 배열 사용

​	보통 객체 배열처럼 사용한다.

### 배열의 반환과 소멸자

​	생성의 반대순으로 소멸된다.

### 동적으로 할당받은 메모리는 반드시 반환해야 하는가?

​	**heap**은 실행중에 **new**를 이용해서 동적으로 할당받아 사용할 수 있는 메모리이다. 사용후 반환하지 않는다면, 힙에 메모리가 부족하여 할당 받을 수 없게되기 때문에 주의가 필요함. **프로그램 종료 시, heap전체가 운영체제에 의해 반환된다.**

### 메모리 누수(memory leak)이 발생하는 경우

```cpp
char n = 'a';
char *p = new char[1024];
p = &n;
```

​	이건 메모리 누수를 발생시킨다. 처음에는 p가 1024바이트의 메모리를 할당받았다. 하지만 p가 n을 가리키게되면, 더 이상 1024바이트의 메모리를 반환할 수 없게됨.(주소를 잃어버렸다)

## this 포인터

​	**this**는 객체 자신에 대한 **포인터**이다. 클래스의 멤버 함수 내에서만 사용가능하다. 지역변수도 아니고 전역변수도 아닌, 멤버함수가 호출될 때 컴파일러에 의해 보이지 않게 전달되는 객체에 대한 주소이다.

### this가 필요한 경우

	1. 멤버 변수의 이름과 동일한 이름으로 매개 변수이름을 짓고자 할 때.
	1. 객체의 멤버 함수에서 **객체 자신의 주소**를 리턴할 때. (Ex 연산자 중복)

### this의 제약 조건

	1. 클래스의 **멤버 함수** 에서만 사용할 수 있다. Why? 멤버 함수가 하는 함수는 그 어떤 객체에도 속해있지 않기 때문에.
	1. **정적 멤버 함수**는 this를 사용할 수 없다. Why? 정적 멤버 함수는 객체가 존재하기 이전에도 존재할 수 있기 때문에.

### 컴파일러가 this를 처리하는 방식

​	189p 읽어보기.

## string 클래스를 이용한 문자열 사용

​	string 클래스는 C++ 표준 라이브러리에서 제공하는 클래스이다. **문자열을 객체로 다룬다.** string은 문자열을 저장하는 버퍼를 가지고, 여러가지 함수가 있음. **스스로 메모리를 조절한다.** 

### string 객체의 동적 생성

```cpp
string *p = new string("C++"); // 동적 생성
p->append("love"); //p가 가리키는 객체의 멤버 함수를 호출한다.

delete p;
```

### string 객체에 문자열 입력

+ \>\>연산자 : 사용하기 쉽지만, 공백을 만나기 전까지만 문자열로 인식한다.
+ getline() 전역 함수를 사용하자.

```cpp
string name;
getline(cin , name, '\n'); //\n을 만날 때까지 키로드로부터 문자열을 읽어서 name에 저장
```


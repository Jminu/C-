# Chapter8 상속

복습: No
작성일시: 2023년 5월 10일 오후 2:47

# C++의 클래스 상속

자신의 멤버 뿐 아니라 부모 클래스의 멤버를 포함할 것을 지시한다. 부모클래스를 **기본 클래스**, 자식 클래스를 **파생클래스** 라고 부른다. c++에서는 여러개의 클래스를 동시에 상속받는 **다중 상속**을 허용한다.

---

## 상속의 목적과 장점

### 1. 간결한 클래스 작성

만약 **동일한 코드** 가 여러 클래스에서 **중복** 된다면, 클래스의 유지 보수가 힘들다. 왜냐면, 모든 클래스에있는 멤버를 하나하나 수정해야하기 때문이다. 하지만, 상속을 한다면 부모 클래스에있는 멤버만 수정하면 되기 때문에 간단해진다. 클래스들 사이의 **중복** 을 제거하여 클래스를 **간결히 구현** 할 수 있다.

### 2. 클래스 간의 계층적 분류 및 관리의 용이함

상속은 클래스들 사이의 관계를 **계층적으로 분류** 할 수 있으며, 이는 구조적인 파악을 쉽게 해준다. → 클래스나 객체의 관리가 유용해진다!

### 3. 클래스 재사용, 확장을 통한 생산성 향상

상속은 기존에 작성해 놓은 클래스를 상속받고 기능을 확장하면서 새로운 소프트웨어를 빨리 만들 수 있다. → **소프트웨어의 생산성 향상**

### 상속 주의!

막 상속하지말고, 관련 있는 클래스를 상속관계로 정의해야한다. 그래야 객체 지향적 특징이 살아난다.

---

## 클래스 상속과 객체

### 상속 선언

```cpp
class Student : public Person {
	//Person을 상속받는 클래스 Student
};
```

이렇게 선언한다.

### 파생 클래스에서 기본 클래스 멤버 접근

파생 클래스는 **상속을 통해** 기본 클래스의 멤버를 자신의 **멤버로 확장** 한다. 파생 클래스의 멤버들은 기본클래스의 private멤버 외에 모든 멤버 접근 가능하다. 

### 기본 클래스의 private 멤버의 상속과 접근

기본 클래스의 **private 멤버도 파생 클래스** 에 상속된다. 파생 클래스의 객체가 생성될 때, 파생 클래스의 객체에 내에 생성된다. 하지만 파생 클래스의 멤버함수에서 기본 클래스의 private변수에 접근은 불가능하다. 따라서 **기본 클래스의 멤버함수를 이용해야 한다.**

→ 기본 클래스에 선언된 private멤버는 파생 클래스에 상속되고 파생 클래스의 객체에도 포함되지만, 파생 클래스의 어떤 함수에서도 직접 접근할 수 없다.

---

## 상속과 객체 포인터

파생 클래스 객체를 **파생 클래스의 포인터** or **기본 클래스의 포인터**로 가르킬 수 있다. 

### 업캐스팅

파생 클래스의 객체를 기본 클래스의 포인터로 가르키는 것을 말한다. 이렇게 하면, 파생 클래스의 객체를 기본 클래스의 객체처럼 다룰 수 있다. → **파생 클래스의 객체가 기본 클래스의 멤버를 포함하기 때문에 가능**

업 캐스팅한 기본 클래스의 포인터로는 **기본 클래스의 멤버만 접근** 가능하다. 그리고 **명시적 타입 변환** 이 필요없다.

### 다운 캐스팅

기본 클래스의 객체를 파생 클래스의 포인터로 가르키는 것을 말한다. 다운 캐스팅은 업 캐스팅과 달리 **명시적 타입 변환** 을 해주어야한다.

다운 캐스팅 시에 기본 클래스에 없는 함수를 호출할 수 있으니 주의하자!

---

## protected 접근 지정

기본 클래스에 protected로 지정된 멤버는 **파생 클래스에게 접근을 허용**하고 다른 클래스나 외부에서 접근을 불허한다. 

---

## 상속과 생성자 / 소멸자

### 파생 클래스와 기본 클래스의 생성자 호출 및 실행 관계

파생 클래스와 기본 클래스는 각각 **생성자** 를 가지고있다.

### 질문

- 파생 클래스의 객체가 생성될 때 파생 클래스의 생성자와 기본 클래스 생성자 둘다 생성됨? → **둘 다 생성된다.**
- 파생 클래스의 생성자와 기본 클래스의 생성자 중 어떤 생성자가 먼저 실행됨? → **기본 클래스 생성자 먼저**

파생클래스의 생성자가 먼저 호출되지만, 실행은 기본 클래스의 생성자가 먼저 실행된다. 기본 클래스의 초기화가 먼저 이뤄지고 파생 클래스의 초기화가 이뤄진다. **컴파일러** 에 의해서.

### 소멸자의 실행 순서

파생 클래스 객체가 소멸할 때, 기본 클래스 파생 클래스의 소멸자도 각각 실행된다. **소멸자의 실행 순서는 생성자의 실행 순서와 반대** 

### 파생 클래스에서 기본 클래스 생성자 호출

파생 클래스의 생성자와 **함께 실행할 기본 클래스의 생성자를** 지정하여야 한다. 만약, 지정하지 않았다면 컴파일러는 묵시적으로 기본 클래스의 기본 생성자가 실행되도록 컴파일한다.

### 명시적인 기본 클래스의 생성자 선택

```cpp
B(int x) : A(x + 3) {
	...
}
```

B(int x) 생성자가 호출되면, 매개 변수로 받은 x에 3을 더하여 생성자 A(int x)의 매개 변수 x에 넘겨준다. 

### 컴파일러의 기본 생성자 호출 코드 삽입

컴파일러가 명시적으로 A() 기본 생성자를 호출하도록 B()생성자를 바꾼다.

```cpp
class B {
	B() : A() {
		...
	}
	B(int x) : A(){
		...
	}
};
```

이렇게 변형한다.

---

## 상속의 종류

- public 상속 → 기본 클래스의 protected, public 멤버들은 상속 지정 변경 없이 파생 클래스에 그대로 상속
- protected 상속 → 기본 클래스의 protect, public 멤버들이 protected로 변경 되서 파생 클래스에 상속
- private 상속 → 기본 클래스의 protected, public 멤버들이 private으로 변경 되서 파생 클래스에 상속

접근 지정자 생략되면 private상속으로 처리된다.
# 함수와 참조, 복사 생성자

프로그래밍 언어의 **인자 전달 방식**은 다음과 같다.

+ 값에 의한 호출(call by value)
+ 주소에 의한 호출(call by address)

**값에 의한 호출**은 호출하는 코드에서 넘겨주는 실인자 값이 함수의 매개변수에 복사되어 전달되는 방식, **주소에 의한 호출**은 주소를 직접 포인터 타입의 매개변수를 전달하는 방식이다.

### '값에 의한 호출'과 '주소에 의한 호출'의 특징

'값에 의한 호출'은 실인자를 **복사**하는 것이기 때문에, 원본이 손상되지 않는다. Side-effect가 없다. 하지만, '주소에 의한 호출'은 실인자의 주솔르 넘겨주기 때문에, 의도적으로 함수 내에서 실인자의 값을 변경하고자 할 때 이용된다. 이들 외에 C++에 **참조에 의한 호출(call by reference)**가 있다.

## 함수 호출시 객체 전달

C++에서는 함수에 객체를 전달할 수 있는데, 이것은 int, char등 기본타입 값을 전달하는 것과는 다르다.

### '값에 의한 호출'로 객체를 전달할 때 문제점

객체가 함수에 전달되면, 함수의 매개 변수 객체가 생성되고, 함수가 종료되면 매개 변수 객체가 소멸한다. 이때, 객체를 매개 변수로 가지는 함수의 경우, 컴파일러가 매개 변수 객체는 **소멸자만 실행된다.** 예를 들어, 함수를 호출한다면 매개 변수로 전해진 객체가 그대로 복사되고(**생성자 실행x**), 함수가 종료될 때 **소멸자가 실행**된다.

#### 이렇게 하는 이유는?

만약 생성자가 생성된다면, **전달 받은 원본**의 상태를 잃어버리기 때문에! -> **비대칭 구조**, 해결법 -> **복사 생성자**

### '주소에 의한 호출'로 객체 전달

객체의 주소를 전달한다.

### '주소에 의한 호출'의 특징

+ 객체 복사시간 x -> 시간 효율성
+ 생성자 소멸자 비대칭 문제 x
+ 원본 객체 훼손 가능성 o

## 객체 치환 및 객체 리턴

### 객체 치환

객체 치환시 모든 데이터가 **비트단위**로 복사

```cpp
Circle c1(10);
Circle c2(20);
c1 = c2 //c2를 c1으로 비트단위로 복사한다.
```

### 함수의 객체 리턴

```cpp
Circle getCircle() {
  Circle c1;
  return c1;
}
```

이 경우에, getCircle() 함수가 호출되고, return 문이 실행되면 **c1의 복사본이 생성**, 그리고 복사본이 getCircle()함수에 호출된 곳으로 전달된다. 그리고 **c1은 소멸된다.**

## 참조와 함수

참조란, **이미 선언된 변수에 대한 별명(alias)**이다. **참조 변수**를 선언하기 위해서는 **&기호**를 사용한다.

+ 참조 변수
+ 참조에 의한 호출
+ 함수의 참조 리턴

### 참조 변수 선언

참조 변수는 이미 선언된 변수의 별명이다. **참조자(&)** 를 이용해서 선언하며, 선언시 **원본 변수로 초기화**하여야 한다. 참조 변수가 선언되면 **참조 변수 이름만 생성**되며 **변수공간이 할당되지 않는다.** 참조 변수는 초기화로 지정된 **원본 변수의 공간을 공유**한다.

## 참조에 의한 호출, call by reference

함수의 매개변수를 참조 타입으로 선언하여, 매개 변수가 함수가 호출하는 쪽의 **실인자를 참조**하여 **실인자와 공간을 공유**하는 인자 전달 방식이다. 이런 매개 변수를 **참조 매개 변수**라고 부른다.

예를 들어, 함수 호출은 **값에 의한 호출**과 모양이 동일하여 헷갈릴 수 있지만, **함수의 원형**으로 구별한다. 

스택에 공간을 할당받지 않는다!!!

## 참조에 의한 호출로 객체 전달

+ 참조 매개 변수로 이루어진 모든 연산 -> 원본 객체에 대한 연산
+ 참조 매개 변수는 이름만 생성 -> 생성자 소멸자 실행안됨

## 참조 리턴

**참조 리턴**이란 현존하는 공간에 대한 리턴이다. 어떤 값을 리턴하는게 아님!!

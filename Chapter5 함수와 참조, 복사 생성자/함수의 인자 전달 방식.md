## 함수의 인자 전달 방식


+ 값에 의한 호출


복사하여 전달하므로, 부작용의 위험이 없다.


+ 주소에 의한 호출


실 인자의 주소를 넘겨준다, 부작용이 있을 수 있음.


## 함수 호출시 객체 전달


**C++은 함수에 객체를 전달 할 수 있다.**


+ 객체를 값에 의한 호출시 문제점


객체를 매개변수로 가질 때, 생성자가 아닌 **소멸자**만 실행된다.




why? 생성자가 또 실행되면 받은 원본의 상태를 잃어버리기 때문에!


+ 주소에 의한 호출로 객체 전달

'값에 의한 호출'시 문제점(소멸자만 실행되는)을 걱정할 필요 없다.


## 객체 치환 및 객체 리턴


### 객체 치환


```cpp
Circle c1(50);
Ciecle c2(20);
c1 = c2;
```


모든 데이터가 복사된다. 하지만, 서로 **다른 객체**인 것을 주의하자


### 함수의 객체 리턴


```cpp
Circle getCircle() {
  Circle tmp(30);
  return tmp;
}
```


를 하면, return 문이 실행되면, tmp복사본이 생기고 전달된다.


그리고 소멸된다.


## 참조와 함수


### 참조란?


선언된 변수에 대한 별명(alias)라고 보면된다.
`&` 로 선언한다.


### 참조는 다음과 같이 활용된다.


+ 참조 변수
+ 참조에 의한 호출
+ 함수의 참조 리턴


### 참조 변수


이미 선언된 변수에 대한 별명.
`&`사용하여 선언한다. 반시시 원본 변수로 초기화 해야한다.


```cpp
int n = 2;
int &refn = n;

Circle c;
Circle &refc = c;
```


참조 변수는 따로 공간x, 공간을 함께 사용한다.


### 참조 변수 사용


참조 변수를 사용하는 것은, 보통 변수와 동일하다.


_참조 변수는 포인터가 아니다!!_


### 참조에 의한 호출


실인자를 참조하여 **실인자와 공간을 공유한다.**


값에의한 호출과 함수 호출이 동일하여 헷갈릴 수 있다. _근데 함수의 원형이 다르다_


ex)
```cpp
void swap(int &a, int &b);

int m=2, n=9;
swap(m, n)
```


**참조 매개 변수** 라고 부른다.


### 참조에 의한 호출 장점


+ 포인터타입으로 매개변수를 설정했을때 -> 주소 전달시 &기호 사용, 함수에서 *기호 반복사용
+ 참조 매개변수를 사용하면, 간단히 변수만 넘겨주면됨


### 참조에 의한 호출로 객체전달 시


+ 참조 매개 변수로 이루어진 모든 연산은 -> 원본 객체의 연산!
+ 생성자, 소멸자 실행 안된다!!! -> 변수 이름만 생성됨


## 참조 리턴



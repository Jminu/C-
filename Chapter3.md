# 클래스와 객체

+ 객체는 캡슐화된다.
+ 객체의 일부는 공개된다
+ 객체 = 맴버 변수 + 멤버 함수

## C++클래스와 C++객체

​	클래스는 객체를 정의하는 틀이다. 객체는 별도 공간에 생성된다. **별도 공간**에 생성된다.

## 클래스 만들기

클래스는 **선언부**와 **구현부**로 나뉘어 작성된다. 그리고 기본 접근지정자는 private이다. 외부에서 접근이 불가능하다.

## 생성자(constructor)

​	객체를 생성할 때, 객체를 초기화한다. 중복가능하다.

+ 객체 생성될 때 초기작업을 위해서
+ 생성자 함수는 **한번**만 실행
+ 클래스이름과 동일해야함
+ 리턴타입이 없다.

### 위임 생성자

​	따로 공부하기

### 그래서, 생성자는 꼭 있어야함?

​	컴파일러는 생성자는 반드시 하나는 호출한다. 만약 생성자 정의되어있지 않다면? **기본 생성자**를 컴파일러가 만든 후 삽입한다.

### 기본 생성자

​	생성자가 하나도 없는 클래스는 컴파일러가 **기본 생성자를 삽입**해준다. 이것은 아무 실행 없이 바로 리턴한다!

### 기본 생성자가 자동 생성되지 않는 경우

​	**생성자가 하나라도 선언된 클래스**는 기본 생성자를 자동 삽입하지 않는다.

## 소멸자

​	객체는 소멸되면 객체 메모리는 시스템으로 반환된다. 객체 소멸시 소멸자 함수가 실행된다. 소멸자는 객체가 소멸되는 시점에서 자동으로 호출되는 클래스의 멤버 함수이다.

+ 마무리 작업 ex) 할당받은 메모리 OS에게 돌려줌
+ 리턴타입 없다. 어떤 값도 리턴하지 않는다.
+ 오직 한개만 존재, 매개변수는 없다.
+ **소멸자 선언 안되있으면, 기본소멸자가 자동으로 생성된다.**

​	소멸자는 객체의 생성의 반대순으로 소멸된다.

## 지역 객체 | 전역 객체

+ **지역 객체**는 함수 안에서 선언된 객체이다. -> 함수가 종료될 때 객체 소멸
+ **전역 객체**는 함수 밖에서 선언된 객체 -> main()이 종료되고 프로그램 메모리가 사라질 때
+ **생성된 순서의 반대로 소멸됨**

## 접근 지정

+ private(비공개) -> 클래스 내의 **멤버함수**만 접근가능
+ public(공개) -> 모두 접근 허용
+ protected(보호) -> **클래스 내의 멤버**와 **상속받은 파생 클래스**에만 허용

### 멤버 보호

​	클래스의 멤버 변수는 private으로 지정하는 것이 바람직하다. **생성자는 public**으로 선언하자!!

## 인라인 함수

​	너무 짧은 함수를 여러번 호출하면? -> **함수 호출 오버헤드** -> 비효율 적이다. 그래서 **inline함수**를 선언한다. 인라인 함수를 선언하면, 컴파일러는 함수를 호출하는 위치에 인라인 함수의 코드를 그대로 삽입한다. So, 호출 오버헤드가 없어지고, **실행속도가 빨라진다.**

+ 작은 함수를 inline으로 선언하자.
+ setter / getter이런 작은 멤버함수들을 inline으로 선언하자.
+ 요청이지 강제명령이 아니다. 컴파일러가 거절할 수 있음.

## C++ 구조체

​	C구조체에 기능을 확장하여, **클래스와 동일한 구조와 기능**을 가진다. 구조체는 **디폴트 접근 지정자**가 **public**이다.

## 바람직한 C++ 프로그램 작성법

​	헤더 파일과 cpp파일을 분리하자. 클래스의 **선언부**는 **헤더파일**, 그리고 **구현부**는 **cpp소스파일**로 분리하자.

### 헤더 파일을 중복 include 할 때 생기는 문제점 해결

​	**조건 컴파일 문**을 삽입하면 된다.


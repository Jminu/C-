# 함수 중복과 static멤버

**함수 중복**은 같은 이름의 함수를 여러개 만들 수 있다. 함수 중복은 **다형성**의 한 사례이다.

### 함수 중복 실패 사례

​	컴파일러는 중복된 함수를 구분할 때, 리턴타입은 고려하지 않는다.!

### 함수 중복의 편리함

​	동일한 이름으로 함수를 여러개 작성할 수 있어서, 편리하다. **이름을 구분**지을 필요가 없다. -> 호출 실수를 줄일 수 있다.

### 생성자 함수도 중복이 가능하다

​	객체를 생성할 때, 매개 변수를 통해 다양한 형태로 초깃값을 전달할 수 있다.

### 소멸자 함수 중복	

​	소멸자는 **매개 변수를 가지지 않음!!**  -> 한 클래스에 하나만 가진다. 그러므로 소멸자는 중복이 불가능 하다.

## 디폴트 매개 변수

```cpp
void star(int a = 5);
```

​	만약, 매개변수를 지정해주지 않는다면, 기본으로 5가 전달된다. 디폴트 매개 변수에 디폴트 값을 전달하는 것은 **컴파일러**에 의해 처리된다.

### 디폴트 매개 변수에 관한 제약 조건

​	디폴트 매개 변수는 **오른쪽 끝 쪽에 몰려 선언**되어야 한다.

### 매개 변수에 값을 정하는 규칙

​	함수 호출문에 나열된 실인자 값들을 **앞에서 부터 순서대로** 함수의 매개 변수에 전달한다. 나머지는 **디폴트 값으로 전달된다.**

```cpp
void square(int width = 1, int height = 1);

square(); //square(1, 1)
square(5); //square(5, 1)
square(3, 8); //square(3, 8)
```

## 함수 중복의 모호성

+ 형 변환으로 인한 모호성
+ 참조 매개 변수로 인한 모호성
+ 디폴트 매개 변수로 인한 모호성

### 형 변환으로 인한 모호성

​	만약에,

```cpp
double square(double a);
...

square(3);
```

​	이 함수의 매개변수 타입은 double형이다. 하지만, 실인자는 int형임. 이럴 때 double형으로 자동 타입변환을 한다. **컴파일러가 낮은 타입에서 큰 타입**으로 자동 형 변환을 한다.

​	하지만,

```cpp
float square(float a);
double square(double a);

square(3);
```

​	을 하면, 컴파일러는 실인자 3을 float로 변환할지 double로 변환할지 모호하다. -> 개발자의 의도와 다를 수 있음.

### 참조 매개 변수로 인한 모호성

```cpp
int add(int a, int b);
int add(int a, int &b); //참조 매개 변수
```

​	이렇게 함수가 있다고 가정하자. 이때,

```cpp
int s = 10;
int t = 20;

add(s, t); //컴파일 오류가 생김 -> 함수 호출 모호성
```

### 디폴트 매개 변수로 인한 모호성

```cpp
void msg(int id);
void msg(int id, string s = " ");

msg(6); //컴파일오류 -> 함수 호출 모호
```

